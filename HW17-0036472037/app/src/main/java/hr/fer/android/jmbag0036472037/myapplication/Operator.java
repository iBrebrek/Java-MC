package hr.fer.android.jmbag0036472037.myapplication;

/**
 * This is an abstract class for every operator.
 * To calculate numbers, which are represented as string,
 * user method {@link #calculate(String, String)}.
 * <br>
 * This class already offers few public immutable operators:
 * <li>{@link #PLUS}</li>
 * <li>{@link #MINUS}</li>
 * <li>{@link #MULTIPLY}</li>
 * <li>{@link #DIVIDE}</li>
 *
 * Created by Ivica Brebrek on 4.7.2016.
 */
public abstract class Operator {

    /**
     * Operator +.
     * Result of {@link #calculate(String, String)}
     * is first+second.
     */
    public static final Operator PLUS = new Operator('+') {
        @Override
        protected double produceResult(double a, double b) {
            return a+b;
        }
    };

    /**
     * Operator -.
     * Result of {@link #calculate(String, String)}
     * is first-second.
     */
    public static final Operator MINUS = new Operator('-') {
        @Override
        protected double produceResult(double a, double b) {
            return a-b;
        }
    };

    /**
     * Operator *.
     * Result of {@link #calculate(String, String)}
     * is first*second.
     */
    public static final Operator MULTIPLY = new Operator('*') {
        @Override
        protected double produceResult(double a, double b) {
            return a*b;
        }
    };

    /**
     * Operator /.
     * Result of {@link #calculate(String, String)}
     * is first/second.
     */
    public static final Operator DIVIDE = new Operator('/') {
        @Override
        protected double produceResult(double a, double b) {
            return a/b;
        }
    };

    /** Visual character used to display operator. */
    private final char sign;

    /** Error message describing why calculating was not successful. */
    private String errorMessage;
    /** Combination of [first][sing][last] that was lastly calculated. */
    private String lastCalculation;

    /**
     * Initializes new operator.
     *
     * @param sign      visual character for this operator.
     */
    public Operator(char sign) {
        this.sign = sign;
    }

    /**
     * Result of <code>a[sign]b</code>
     * where [sign] is sign given in constructor.
     *
     * @param a     first operand.
     * @param b     second operand.
     * @return result of operation.
     */
    protected abstract double produceResult(double a, double b);

    /**
     * Result of <code>first[sign]second</code>
     * where [sign] is sign given in constructor.
     * <br>
     * Given operands are strings, but they must be
     * parsable to double. If they are not parsable,
     * this method will return <code>null</code>.
     * Also, if <code>null</code> is returned,
     * explanation why calculation was not successful
     * can be retrieved by calling {@link #getErrorMessage()}.
     *
     * @param first     first operand as string.
     * @param second     second operand as string.
     * @return result of operation as string.
     */
    public final String calculate(String first, String second) {
        try {
            double a = Double.parseDouble(first);
            double b = Double.parseDouble(second);
            lastCalculation = first+sign+second;
            return String.valueOf(produceResult(a, b));

        } catch(NumberFormatException e1) {
            if(first.isEmpty() || second.isEmpty()) {
                errorMessage = "Can not calculate with empty input.";
            } else {
                errorMessage = "Too hard to calculate with so big number.";
            }
        } catch(NullPointerException e2) {
            errorMessage = "Can not calculate with null.";
        }
        return null;
    }

    /**
     * Combination of [first][sing][last] that was lastly calculated.
     * If nothing was calculated yet, <code>null</code> is returned.
     *
     * @return last calculation done, or <code>null</code> if there is none.
     */
    public String getLastCalculation() {
        return lastCalculation;
    }

    /**
     * Last error message that was generated by method
     * {@link #calculate(String, String)} when calculation was not possible.
     * If there is not last error, then <code>null</code> is returned.
     *
     * @return explanation why {@link #calculate(String, String)} returned <code>null</code>.
     */
    public String getErrorMessage() {
        return errorMessage;
    }

    @Override
    public String toString() {
        return String.valueOf(sign);
    }
}